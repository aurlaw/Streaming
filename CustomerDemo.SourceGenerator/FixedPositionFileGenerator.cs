using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CustomerDemo.SourceGenerator
{
    [Generator]
    public class FixedPositionFileGenerator : ISourceGenerator
    {
        private const string ReportItemAttributeName = "ReportItemAttribute";
        private const string ReportItemAttributeShortName = "ReportItem";
        private const string GenerateSerializerAttributeName = "GenerateSerializerAttribute";
        private const string GenerateSerializerAttributeShortName = "GenerateSerializer";
        private const string GeneratedNamespace = "CustomerDemo.Serialization";
        private const string GeneratedClassName = "GeneratedFileSerializer";

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForPostInitialization(i => i.AddSource(
                "GenerateSerializerAttribute.g.cs",
                SourceText.From(GenerateSerializerAttributeSource, Encoding.UTF8)));

            context.RegisterForSyntaxNotifications(() => new ReportItemSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not ReportItemSyntaxReceiver receiver)
                return;

            var compilation = context.Compilation;
            var classesWithSerializer = new List<(INamedTypeSymbol Symbol, string RecordType)>();

            foreach (var classDeclaration in receiver.CandidateClasses)
            {
                var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                var classSymbol = model.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

                if (classSymbol == null)
                    continue;

                var serializerAttr = GetGenerateSerializerAttribute(classSymbol);
                if (serializerAttr != null)
                {
                    var recordType = GetRecordType(serializerAttr);
                    classesWithSerializer.Add((classSymbol, recordType));
                }
            }

            if (classesWithSerializer.Count == 0)
                return;

            var source = GenerateSerializer(classesWithSerializer);
            context.AddSource($"{GeneratedClassName}.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        private string GenerateSerializer(List<(INamedTypeSymbol Symbol, string RecordType)> classes)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System.Text;");
            sb.AppendLine("using CustomerDemo.Models;");
            sb.AppendLine();
            sb.AppendLine($"namespace {GeneratedNamespace}");
            sb.AppendLine("{");
            sb.AppendLine($"    public class {GeneratedClassName}");
            sb.AppendLine("    {");

            var rootClass = FindRootClass(classes);
            if (rootClass.Symbol != null)
            {
                GenerateMainSerializeMethod(sb, rootClass);
                sb.AppendLine();
            }

            foreach (var (classSymbol, recordType) in classes)
            {
                GenerateSerializeMethod(sb, classSymbol, recordType, classes);
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private (INamedTypeSymbol? Symbol, string RecordType) FindRootClass(
            List<(INamedTypeSymbol Symbol, string RecordType)> classes)
        {
            foreach (var (classSymbol, recordType) in classes)
            {
                bool isChildOfAnother = false;

                foreach (var (otherClass, _) in classes)
                {
                    if (SymbolEqualityComparer.Default.Equals(classSymbol, otherClass))
                        continue;

                    var properties = otherClass.GetMembers().OfType<IPropertySymbol>();
                    foreach (var prop in properties)
                    {
                        var propType = GetUnderlyingType(prop.Type);
                        if (SymbolEqualityComparer.Default.Equals(propType, classSymbol))
                        {
                            isChildOfAnother = true;
                            break;
                        }
                    }

                    if (isChildOfAnother)
                        break;
                }

                if (!isChildOfAnother)
                {
                    return (classSymbol, recordType);
                }
            }

            return classes.FirstOrDefault();
        }

        private void GenerateMainSerializeMethod(
            StringBuilder sb,
            (INamedTypeSymbol Symbol, string RecordType) rootClass)
        {
            var className = rootClass.Symbol.Name;
            var fullTypeName = rootClass.Symbol.ToDisplayString();

            sb.AppendLine($"        public string Serialize(List<{fullTypeName}> items)");
            sb.AppendLine("        {");
            sb.AppendLine("            var sb = new StringBuilder();");
            sb.AppendLine();
            sb.AppendLine("            foreach (var item in items)");
            sb.AppendLine("            {");
            sb.AppendLine($"                Serialize{className}Recursive(item, sb);");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            return sb.ToString();");
            sb.AppendLine("        }");
        }

        private void GenerateSerializeMethod(
            StringBuilder sb,
            INamedTypeSymbol classSymbol,
            string recordType,
            List<(INamedTypeSymbol Symbol, string RecordType)> classes)
        {
            var className = classSymbol.Name;
            var fullTypeName = classSymbol.ToDisplayString();

            var reportItemProperties = classSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Select(p => new
                {
                    Property = p,
                    Attribute = GetReportItemAttributeData(p)
                })
                .Where(x => x.Attribute != null)
                .OrderBy(x => GetOrder(x.Attribute!))
                .ToList();

            var serializableProperties = classSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(p => !HasReportItemAttribute(p))
                .Select(p => new
                {
                    Property = p,
                    UnderlyingType = GetUnderlyingType(p.Type),
                    IsList = IsListType(p.Type)
                })
                .Where(x => classes.Any(c => SymbolEqualityComparer.Default.Equals(c.Symbol, x.UnderlyingType)))
                .ToList();

            // Generate line serialization method
            sb.AppendLine($"        private string Serialize{className}({fullTypeName} obj)");
            sb.AppendLine("        {");
            sb.AppendLine("            var sb = new StringBuilder();");
            sb.AppendLine($"            sb.Append(\"{recordType}\");");

            foreach (var prop in reportItemProperties)
            {
                var attr = prop.Attribute!;
                var propertyName = prop.Property.Name;
                var propertyType = prop.Property.Type;
                var maxLength = GetMaxLength(attr);
                var paddingChar = GetPaddingChar(attr);
                var paddingDirection = GetPaddingDirection(attr);

                string formatCode = GenerateFormatCode(propertyName, propertyType, maxLength, paddingChar, paddingDirection);
                sb.AppendLine($"            sb.Append({formatCode});");
            }

            sb.AppendLine("            return sb.ToString();");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate recursive serialization method
            sb.AppendLine($"        private void Serialize{className}Recursive({fullTypeName} obj, StringBuilder sb)");
            sb.AppendLine("        {");
            sb.AppendLine($"            sb.AppendLine(Serialize{className}(obj));");
            sb.AppendLine();

            foreach (var prop in serializableProperties)
            {
                var propName = prop.Property.Name;
                var childClassName = prop.UnderlyingType!.Name;

                if (prop.IsList)
                {
                    sb.AppendLine($"            foreach (var item in obj.{propName})");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                Serialize{childClassName}Recursive(item, sb);");
                    sb.AppendLine("            }");
                }
                else
                {
                    sb.AppendLine($"            if (obj.{propName} != null)");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                Serialize{childClassName}Recursive(obj.{propName}, sb);");
                    sb.AppendLine("            }");
                }
                sb.AppendLine();
            }

            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private string GenerateFormatCode(string propertyName, ITypeSymbol propertyType, int maxLength, char paddingChar, string paddingDirection)
        {
            var typeName = propertyType.ToDisplayString();
            string valueExpression;

            if (typeName == "int")
            {
                valueExpression = $"obj.{propertyName}.ToString()";
            }
            else if (typeName == "decimal")
            {
                valueExpression = $"obj.{propertyName}.ToString(\"F2\").Replace(\".\", \"\")";
            }
            else if (typeName == "string")
            {
                valueExpression = $"(obj.{propertyName} ?? string.Empty)";
            }
            else
            {
                valueExpression = $"(obj.{propertyName}?.ToString() ?? string.Empty)";
            }

            var truncateCode = $"({valueExpression}.Length > {maxLength} ? {valueExpression}.Substring(0, {maxLength}) : {valueExpression})";

            if (paddingDirection == "Left")
            {
                return $"{truncateCode}.PadLeft({maxLength}, '{paddingChar}')";
            }
            else
            {
                return $"{truncateCode}.PadRight({maxLength}, '{paddingChar}')";
            }
        }

        private INamedTypeSymbol? GetUnderlyingType(ITypeSymbol type)
        {
            if (type is INamedTypeSymbol namedType)
            {
                if (namedType.IsGenericType &&
                    (namedType.OriginalDefinition.ToDisplayString().StartsWith("System.Collections.Generic.List<") ||
                     namedType.OriginalDefinition.ToDisplayString().StartsWith("System.Collections.Generic.IEnumerable<")))
                {
                    return namedType.TypeArguments[0] as INamedTypeSymbol;
                }

                return namedType;
            }

            return null;
        }

        private bool IsListType(ITypeSymbol type)
        {
            if (type is INamedTypeSymbol namedType && namedType.IsGenericType)
            {
                var typeName = namedType.OriginalDefinition.ToDisplayString();
                return typeName.StartsWith("System.Collections.Generic.List<") ||
                       typeName.StartsWith("System.Collections.Generic.IEnumerable<");
            }

            return false;
        }

        private AttributeData? GetGenerateSerializerAttribute(INamedTypeSymbol classSymbol)
        {
            return classSymbol.GetAttributes()
                .FirstOrDefault(ad =>
                    ad.AttributeClass?.Name == GenerateSerializerAttributeName ||
                    ad.AttributeClass?.Name == GenerateSerializerAttributeShortName);
        }

        private string GetRecordType(AttributeData attr)
        {
            if (attr.ConstructorArguments.Length > 0)
            {
                return (string)attr.ConstructorArguments[0].Value!;
            }
            return "X";
        }

        private bool HasReportItemAttribute(IPropertySymbol property)
        {
            return property.GetAttributes().Any(ad =>
                ad.AttributeClass?.Name == ReportItemAttributeName ||
                ad.AttributeClass?.Name == ReportItemAttributeShortName);
        }

        private AttributeData? GetReportItemAttributeData(IPropertySymbol property)
        {
            return property.GetAttributes()
                .FirstOrDefault(ad =>
                    ad.AttributeClass?.Name == ReportItemAttributeName ||
                    ad.AttributeClass?.Name == ReportItemAttributeShortName);
        }

        private int GetOrder(AttributeData attr)
        {
            return (int)attr.ConstructorArguments[0].Value!;
        }

        private int GetMaxLength(AttributeData attr)
        {
            return (int)attr.ConstructorArguments[1].Value!;
        }

        private char GetPaddingChar(AttributeData attr)
        {
            if (attr.ConstructorArguments.Length > 2)
            {
                return (char)attr.ConstructorArguments[2].Value!;
            }

            var paddingCharArg = attr.NamedArguments.FirstOrDefault(x => x.Key == "PaddingChar");
            if (paddingCharArg.Key != null)
            {
                return (char)paddingCharArg.Value.Value!;
            }

            return ' ';
        }

        private string GetPaddingDirection(AttributeData attr)
        {
            if (attr.ConstructorArguments.Length > 3)
            {
                var enumValue = (int)attr.ConstructorArguments[3].Value!;
                return enumValue == 0 ? "Left" : "Right";
            }

            var paddingDirArg = attr.NamedArguments.FirstOrDefault(x => x.Key == "PaddingDirection");
            if (paddingDirArg.Key != null)
            {
                var enumValue = (int)paddingDirArg.Value.Value!;
                return enumValue == 0 ? "Left" : "Right";
            }

            return "Right";
        }

        private const string GenerateSerializerAttributeSource = @"// <auto-generated/>
#nullable enable

namespace CustomerDemo.Attributes
{
    [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class GenerateSerializerAttribute : System.Attribute
    {
        public string RecordType { get; set; }

        public GenerateSerializerAttribute(string recordType)
        {
            RecordType = recordType;
        }
    }
}
";
    }

    class ReportItemSyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
                classDeclaration.AttributeLists.Count > 0)
            {
                CandidateClasses.Add(classDeclaration);
            }
        }
    }
}